#被继承的类为基类，继承的类叫子类
#类继承有三种方式：
# 1、实现继承：使用基类的属性和方法而无须额编码的能力
# 2、接口继承：仅使用属性和方法的名称，但是子类必须提供实现的能力
#3、可视继承：子窗体和基窗体的外观和实现代码的能力

#类之间要继承的话必须是从属关系，Employee类和manager类从属于Person类，但是Leg类只能
#从属于manager和employee类，不能继承Person类


'''
class Person(object):
    def __init__(self,name,sex):
        self.name=name
        self.sex=sex                             #类
    def print_title(self):
        if self.sex=='male':
            print('male')
        elif self.sex=='female':
            print("female")
class Child(Person):       #Child 继承父类Person
    pass

May=Child("May","female")
Peter=Person("Peter",'male')

print(May.name,May.sex,Peter.name,Peter.sex) #子类继承父类的方法和属性
May.print_title()  #May作为Child类，可以使用父类中的print_title()方法
Peter.print_title()
'''


#继承有什么好处？最大的好处是子类获得了父类的全部属性及功能。如下 Child 类就可以直接使用父类的 print_title() 方法
#实例化Child的时候，子类继承了父类的构造函数，就需要提供父类Person要求的两个属性变量 name 及 sex
#Python拥有可以判断是否继承的函数，isinstance（）和issubclass（）：
'''
class father():
    pass
class son(father):
    pass
Ben=son()
Sally=father()
print(isinstance(Ben,father))  #true，说明了继承了父类的子类也拥有父类的类型
print(isinstance(Sally,father))   #true
print(isinstance(Sally,son))    #False,父类没有子类的类型
print(isinstance(Ben,son))      #true
print(issubclass(son,father))   #true
'''

#多态
'''
class Person(object):
      def __init__(self,name,sex):
          self.name = name
          self.sex = sex
      def print_title(self):
          if self.sex == "male":
              print("M")
          elif self.sex == "female":
              print("F")


class Child(Person):                # Child 继承 Person
     def print_title(self):
         if self.sex == "male":
             print("boy")
         elif self.sex == "female":
             print("girl")

Peter= Child("Peter","male")
May = Person("May","female")

print(May.name,May.sex,Peter.name,Peter.sex)
May.print_title()     #输出girl
Peter.print_title()   #输出M
'''
#在这个case中可以很清楚地看到，父类Person和子类Child都拥有print_title()的功能
#在May（Person类的对象）使用print_title方法的时候调用的是Person类中的方法
#而Peter(Child类的对象）则调用了自己的print_title方法

#多态在此得到体现，当写Person的子类时（Child，Teenager，Grownup等）的时候，可以直接调用Person中的方法（如方法A）。而如果我们想在子类中对Person中的方法进行修改or扩展时，便可以在子类中重写这个方法（将方法A改写成子类的方法A1）
#在使用子类时，系统会读取子类中的方法A1而不是Person中的方法A。如子类中没写方法A，系统则读取Person中的方法A
#这叫做多态


#子类重写构造函数
'''
class Person(object):
    def __init__(self,name,sex):
        self.name=name
        self.sex=sex

class Child(Person):
    def __init__(self,name,sex,father,mother):
        Person.__init__(self,name,sex)   #子类对父类构造方法的调用，用于减少冗余代码
        self.mother=mother               #意为向Person类中增加属性
        self.father=father
May=Child("May","male","Keen","Alice")
print(May.name,May.sex,May.father,May.mother)

#输出 May male Keen Alice
'''
#子类重写构造函数的效果等于：
'''
class Person(object):
  def __init__(self,name,sex,father,mother):
       self.name=name
       self.sex=sex
       self.father=father
       self.mother=mother

May=Person("May","Female","John","Marry")
print(May.name,May.sex,May.father,May.mother)
'''
#在多重继承中，如Person-Child-Baby这样的层级中，最低层类Baby可以继承Person的属性和方法
#如产生多态时，Baby也会优先使用Child类中的方法

'''
#封装
#实例化的含义是：实例化是指在面向对象的编程中，通常把用类创建对象的过程称为实例化。格式化有类名，对象名 = new 类名（参数1，参数2...参数n）。
#封装的意义是就是将类或者是函数中的某些属性限制在某个区域之内，外部无法调用。而外部调用的只能是类提供的某个接口
#封装中以__x（左双下划线）表示封装，x为数据或者属性。只有类内部能访问
#如：
class Person:                            #类的定义
    def __init__(self,name,sex):          #属性由name和sex
        self.name=name
        self.sex=sex
    def __output(self):                  #被封装的output函数，只能在类的里面访问
        if self.name=='Mary'and self.sex=='Female':     #私有化函数的功能被封装
            return 1
    def output1(self):
        if self.__output()==1:             #调用被封装的函数
            print("Mary is Female")
Mary=Person('Mary','Female')
#Mary.__output()                #会报错AttributeError: 'Person' object has no attribute '__output'
Mary.output1()                  #输出Mary is Female
'''





'''
#拥有双下划线的私有化属性、方法，其实是可以访问的，但是要通过变形后的样子访问
class Person:                            #类的定义
    __N=0                                 #将类设为私有的
    def __init__(self,name,sex):          #属性由name和sex
        self.name=name
        self.sex=sex
        self.__x=10                        #类的私有属性
    def __output(self):                  #被封装的output函数，只能在类的里面访问
        if self.name=='Mary'and self.sex=='Female':  #私有化函数的功能被封装
            print("a")
            return 1
    def output1(self):
        if self.__output()==1:             #调用被封装的函数
            print("Mary is Female")

Mary=Person("Mary","Female")
print(Mary._Person__N)        #要访问私有类，格式为：对象._类名__属性名，这里输出为0
print(Mary._Person__output()) #访问私有类方法__output,格式为：对象._类名__方法名，这里输出a，return 1
print(Person._Person__N)      #输出0
print(Mary._Person__x)        #输出10，对应self.__x
'''




'''
#私有化类的继承问题
class Person(object):
    __N=0
    def __init__(self,name,sex):
        self.name=name
        self.sex=sex
    def test2(self):
        if self.mother =='Alice':
            print("2")
    def test(self):
        self.test()
class Child(Person):
    def __init__(self,name,sex,father,mother):
        Person.__init__(self,name,sex)   #子类对父类构造方法的调用，用于减少冗余代码
        self.mother=mother               #意为向Person类中增加属性
        self.father=father
    def test2(self):
        if self.mother =='Alice':
            print("1")
May=Child("May","male","Keen","Alice")
May.test2()    #这里输出是1，即Child类的test2方法覆盖了父类的test2方法。
'''

#如果不想child的test2覆盖Person，则需要吧test2私有化。

class Person(object):
    __N=0
    def __init__(self,name,sex):
        self.name=name
        self.sex=sex
    def __test2(self):
        if self.mother =='Alice':
            print("2")
    def test(self):
        self.test()
class Child(Person):
    def __init__(self,name,sex,father,mother):
        Person.__init__(self,name,sex)   #子类对父类构造方法的调用，用于减少冗余代码
        self.mother=mother               #意为向Person类中增加属性
        self.father=father
    def __test2(self):
        if self.mother =='Alice':
            print("1")
May=Child("May","male","Keen","Alice")
May._Person__test2() #输出2，父类的方法没被子类覆盖












'''
class role(object):   #d定义角色类
    def __init__(self, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
        self.name = name
        self.role = role
        self.weapon = weapon
        self.life_val = life_value

    def buy_weapon(self, weapon):
        print("{0} is buying {1}".format(self.name, self.weapon))
        self.weapon=weapon

Tom = role("TOM", 'Police', "AK", 100)  #相当于role(Tom,"TOM", 'Police', "AK", 100),Tom是-->role的实例对象，role是一个抽象的类，被变成了具体的对象Tom,过程叫实例化。实例即self
print(Tom.weapon)
Tom.buy_weapon('M1A6')  #内部转换成Role.buy_weapon("Tom","M6A1")
print(Tom.weapon)

#输出：
#AK
#TOM is buying AK    #使用Tom.buy_weapon('M1A6')命令后，self.weapon被重新定义为M1A6
#M1A6
'''
'''
#除了函数以外，类的属性也可以直接写：
class role(object):   #定义角色类
    ac=0
    def __init__(self, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
        self.name = name
        self.role = role
        self.weapon = weapon
        self.life_val = life_value
Tom=role("TOM","PL","AK","100")
print(Tom.ac)       #输出0
Tom.ac=1           
print(Tom.ac)      #输出1
role.ac=3         #将类属性改变
Alice=role("ALICE","PL","AK","100")  #创建第二个实例Alice
print(Tom.ac)     #输出1
print(Alice.ac)   #输出3         #在改变类的属性后，Tom和Alice的ac不一致


#可以看到，在role.ac=3这个命令之前，实例Tom的变量ac=1，且之后再命名role这个类的ac属性=3的时候，实例Tom的ac还是1
#但是在role.ac=3这个命令之后的实例Alice的ac变量却变为了3

'''
'''
class role(object):   #d定义角色类
    ac=0
    def __init__(self, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
        self.name = name
        self.role = role
        self.weapon = weapon
        self.life_val = life_value
t1=role('t1','p','AA',100)
role.ac=3
role.weapon='BB'
t2=role('t2','p','AB',100)
print(t1.ac)
print(t2.ac)
print(t1.weapon)
print(t2.weapon)

#输出：
#3
#3
#AA
#AB

#可以看到，在没有声明t1.ac=1的时候，直接声明将类变量ac改编为3，t1.ac输出也是3，不像上一个例子中，ac在tom.ac=1这条声明之后输出为1
#而同时，初始化方法内的属性weapon，即使声明了他等于BB之后，不管是之前的t1,还是之后的t2在输出的时候，weapon属性均为实例化时输入的值，未改变为BB
#原因如下：

#首先，在将role存入内存后，运行print(role.ac),会输出0，而运行print(role.weapon)会报错（no attribute)
#ac作为role的一部分，在将role这个类存入内存时也储存了ac。ac被储存在role的内存空间里
# 而weapon属性则是在类role实例化（即执行__init__函数）的时候才会出现，init函数的属性（weapon，name等）都存储在实例化对象的内存空间里
#所以任何对role类的ac的改变都会使其变化，而weapon不行。但是！！！role.weapon=“BB”这个命令是起作用的，作用是在role这个类里面增加了一个名为weapon变量，变成和ac一回事的东西了

print(role.weapon)   #输出BB，变为了类变量

#所以！！ac被称为类属性or类变量，储存在类的内存空间。，__init__中的weapon，name等属性被称为成员属性or成员变量，在实例化后存在实例的内存空间
#同时，在上例中，在声明Tom.ac=1后！输出Tom.ac=1。这里ac访问的不是类储存空间里的ac，而是在Tom的实例空间里创建了一个属性叫做ac
#类似于变成了__init__(self,name,role,weapon,life_value,ac)
'''



#类变量的使用
'''
class Role(object):   #d定义角色类
    menbers=0
    def __init__(self, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
        self.name = name
        self.role = role
        self.weapon = weapon
        self.life_val = life_value
        Role.menbers += 1
t1=Role('t1','p','AA',100)
t2=Role('t2','p','AA',100)
t3=Role('t3','p','AA',100)
print(Role.menbers)
'''
#实例每次初始化都会调用__init__函数，而menbers存储在Role类的内存空间
#所以每实例化一次，Role.menbers += 1都会被执行一次


#类的方法调用问题：
'''
def buy_weapon(self, weapon):
    print("{0} is buying {1}".format(self.name, self.weapon))
    self.weapon = weapon
'''
#为什么要写self.weapon=weapon？
#类的方法存在类的内存空间，实例用self.weapon访问buy_weapon函数
#拥有self的是““实例方法””，实例能够调用实例方法，如上
#self也可以写其他的
'''
class Role(object):   #d定义角色类
    def __init__(foo, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
       foo.name = name
       foo.role = role
       foo.weapon = weapon
       foo.life_val = life_value
    def hi(here):
        print(here.name)
t1=Role('T1','p','AA',100)
t1.hi()    #输出T1
'''
#静态方法是一种普通函数，不会对任何实例类型进行操作。使用@装饰器定义静态方法。
#类对象（如类自身：Role）和实例（t1)都可以调用静态方法
'''
class Role(object):   #d定义角色类
    def __init__(foo, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
       foo.name = name
       foo.role = role
       foo.weapon = weapon
       foo.life_val = life_value
    def hi(here):
        print(here.name)
    @staticmethod
    def add(a,b):
        print(a+b)
t1=Role('T1','p','AA',100)
t1.hi()   #T1
t1.add(1,2)  #3
Role.add(1,3)  #4
'''

#类方法
#类方法将类本身作为对象，类似于将类实例化。需要@classmothod装饰器
#类对象（如类自身：Role）和实例（t1)都可以调用类方法
'''
class Role(object):   #d定义角色类
    sc='AA'
    def __init__(foo, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
       foo.name = name
       foo.role = role
       foo.weapon = weapon
       foo.life_val = life_value
    @classmethod
    def hi(cls,x):
        print(cls.sc*x)    #操作类，类的属性等，cls指代类
t1=Role('T1','p','AA',100)  #实例化
t1.hi(2)   #AAAA    #在这里实例调用了类方法，这在其他很多语言不允许
Role.hi(3)  #AAAAAA
'''



#super
#super用于执行父类中的函数

class Role(object):   #d定义角色类
    def __init__(self, name, role, weapon, life_value): #角色有名字，角色，武器，生命值四个属性
       self.name = name
       self.role = role
       self.weapon = weapon
       self.life_val = life_value
    def hi(self):
        print(self.name)

class Role2(Role):
    def hi(self):
        super(Role2,self).hi()
t1=Role2('T1','p','AA',100)
t1.hi()   #输出T1,这是Role中的方法，但是通过super可以被Role2的实例调用


#实例变量为self.开头，储存在实例的内存空间。类变量在类中，储存在类的内存
#实例可以访问类变量
#除了通过类似t1.sc的方法访问外，还可以
'''
class Foo(object):
    val=3
    def __int__(self,a):
        self.a=a
        print(self.__class__.val)
foo=Foo()







